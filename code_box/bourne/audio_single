#!/bin/bash
### fehlen noch command line switches um die Nachfragrerei zu unterbinden bzw zu ermöglichen
IFS='
'

top_music_dir="$1"

## colors
rot='\033[1;31m'
grn='\033[0;32m'
blu='\033[1;34m'
off='\033[0m'

## sanitize filenames for final renaming
lowercase () {
  sed 's;[^[:alnum:][:space:]&_()-];;g' | tr '[:upper:]' '[:lower:]'
}


## extract tag information of individual files
get_artist () {
  TPEX=($(id3info "$1" | grep TPE))
  TPE1=$( sed -n 's;^=.*TPE*1.*: ;;p' <<< "${TPEX[*]}" | lowercase )
  TPE2=$( sed -n 's;^=.*TPE*2.*: ;;p' <<< "${TPEX[*]}" | lowercase )
  if [[ -z "$TPE1" ]] && [[ -z "$TPE2" ]]; then
    TPE=$( exiftool -s3 -artist "$1" | lowercase )
    band+=("$TPE")
  else
    if [[ -n "$TPE1" ]]; then
      band1+=("$TPE1")
    fi
    if [[ -n "$TPE2" ]]; then
      band2+=("$TPE2")
    fi
  fi
}

get_album () {
  TAL=$( id3info "$1" | sed -n 's;^=.*TALB*.*): ;;p' | lowercase )
  if [[ -z "$TAL" ]]; then
    TAL=$( exiftool -s3 -album "$1" | lowercase )
  fi
  albu+=("$TAL")
}

## test for empty directories; possibly better with 'du -s'?
test_empty_dir () {
  if [[ -z "$(ls -A $1)" ]]; then
    read -n 1 -p "this one's empty and will be removed, do you like that? [y/n]" ny
    case "$ny" in
      [Yy]) set -x; rm -r "$1"; set +x; continue ;;
    *) continue;;
  esac
fi
}

## test whether directory contains any audio files
test_for_audio () {
  if [[ -z $(file -b "$1"/* | grep -i "audio") ]]; then
    echo -e " there are no audio files in this directory. maybe images or playlists?"
    if [[ $(dirname "$1") =~ "_noaudio" ]]; then						  # skip, if already under the _noaudio directory
      echo -e "already under _noaudio, ${blu}skipping...${off}"
      continue
    else
      read -n 1 -p "move to ${top_music_dir}_noaudio/$(basename ${1})? [y/n]" yn
      case "$yn" in
	[Yy] ) 
	  set -x
	  if [[ -d "${top_music_dir}_noaudio" ]]; then 
	    cp -R "$1" "${top_music_dir}_noaudio" && rm -r "$1"
	  else
	    mkdir "${top_music_dir}_noaudio" && cp -R "$1" "${top_music_dir}_noaudio" && rm -r "$1"
	  fi
	  set +x ;;
	* ) continue ;;
      esac
    fi
  fi
}

gettagsfromfile () {
  echo -e "${blu}$1 is a regular file which does not conern us right now...${off}"
  extn=${1##*.}
  band=$(exiftool -s3 -Artist $1 | lowercase)
  albu=$(exiftool -s3 -Album $1 | lowercase)
  song=$(exiftool -s3 -Title $1 | lowercase)
  trac=$(exiftool -s3 -Track $1 | lowercase)
  trnm=$(printf "%02d" $((10#${trac%%/*})) )
  echo "$band - $albu - $trnm - $song"
  echo "Dateiendung = $extn"
}

dir_analysis () {
  if [[ -f "$1" ]]; then									    # if $1 is a regular file, get tracknumber and stuff
    gettagsfromfile "$1"

  elif [[ -d "$1" ]]; then									    # if $1 is a regular directory...
    test_empty_dir "$1"										    # ... check, whether empty
    test_for_audio "$1"										    # ... check, whether there's audio files
    unset band band1 band2 bandall albu											    # reset array
    echo -e -n " ...and is a directory - analysing\n..."

    for i in $(find $1 -mindepth 1 -maxdepth 1 -type f); do   # should iterate over leaf directories. yet to implement the search for leaf directories
      if [[ -n $(file -b "$i" | grep -i "audio\|mpeg\|44.1") ]]; then	    #if this is an audio file, check for artist and album id3-tags
	get_artist "$i"
	get_album "$i"
      fi
      echo -ne "."
    done
    echo -ne "arrays für album und artist befüllt\n"


    #### Auswertung, ob Artist eindeutig ist
    bandall=("${band[@]}" "${band1[@]}" "${band2[@]}") 
    bandlist_topresult=$( echo "${bandall[*]}" | sort |  uniq -c | sort -nr | sed 's;^[[:space:]]*;;g' | head -n1 )
    mosthits_number=$(sed 's;\(^[[:digit:]]*\).*;\1;' <<< "$bandlist_topresult")
    mosthits_value=$(sed 's;^[[:digit:]]*[[:space:]]*;;' <<< "$bandlist_topresult")
    bperc=$(echo "scale=4;($mosthits_number/${#bandall[*]})*100.0" | bc -l | cut -d '.' -f1)	    # $perc = oberster Treffer aller bandarrays zusammen / ergebnisse aller bandarrays

    if [[ "$bperc" -ge 60 ]] && [[ -n "$mosthits_value" ]]; then    # wenn das oberste ergebnis nicht leer ist und über 60% der gefundenen Namen darstellt
      echo -ne "$mosthits_value ($bperc%) - "
      bandname="$mosthits_value"
    elif [[ "$bperc" -le 60 ]]; then					# wenn das oberste Ergebnis weniger als 60% ausmacht















      band1_nooflines=$( sort <<< "${band1[*]}" | uniq -c | wc -l )	# oberste ergebnisse der einzelnen arrays lesen
      band2_nooflines=$( sort <<< "${band2[*]}" | uniq -c | wc -l )
      if [[ "$bperc" -eq "50" ]] && [[ $band1_nooflines == $band2_nooflines ]] ; then
	bandname="$mosthits_value"
      elif [[ "$bperc" -ne "50" ]] && ( [[ -n "$mosthits_value" ]] && [[ $band1_nooflines == 1 ]] || [[ $band2_nooflines == 1 ]] ); then  ## wenn eins der arrays nur aus einem ergebnis besteht
	mosthits_value_1=$(sort -u <<< "${band1[*]}" | head -n1)
	mosthits_value_2=$(sort -u <<< "${band2[*]}" | head -n1)
	echo -e "equally frequent results for band are:\n$mosthits_value_1 [1]\n$mosthits_value_2 [2]\n choose [1] or [2] for given results or [3] for unknown"
	read -n 1 selectband
	case "$selectband" in
	  1) bandname="$mosthits_value_1";;
	  2) bandname="$mosthits_value_2";;
          *) bandname="unknown_artist" ;;
        esac
      fi
    else
  echo -ne "$mosthits_value ($bperc%) - "
  echo "keine eindeutige zuordnung möglich"
  echo "mögliche artists: "
  possible_hits=$( sort <<< "${bandall[*]}" | uniq -c | sort -nr | sed 's;^[[:space:]]*;;g' | head -n3 )
  echo "$possible_hits"
  echo -e "${1}:\n$possible_hits\n----\n" >> "$top_music_dir$( date +%s )" 
  bandname="unknown_artist"
fi
unset mosthits_number
unset mosthits_value

#### Auswertung, ob Album eindeutig ist
albulist_topresult=$( echo "${albu[*]}" | sort -nr | uniq -c | sed 's;^[[:space:]]*;;g' | head -n1 )
mosthits_number=$(sed 's;\(^[[:digit:]]*\).*;\1;' <<< "$albulist_topresult")
mosthits_value=$(sed 's;^[[:digit:]]*[[:space:]]*;;' <<< "$albulist_topresult")
aperc=$(echo "scale=4;($mosthits_number/${#albu[*]})*100.0" | bc -l | cut -d '.' -f1)	    # $perc = Prozent, die ein Ergebnis ausmacht
if [[ "$aperc" -ge 60 ]] && [[ -n "$mosthits_value" ]]; then
  echo -ne "$mosthits_value ($aperc%) - "
  albuname="$mosthits_value"
else
  echo -ne "$mosthits_value ($aperc%) - "
  echo "keine eindeutige zuordnung möglich"
  albuname="unknown_album"
fi
unset mosthits_number
unset mosthits_value


#### wenn eins von beidem  unbekannt ist, nichts tun
if [[ "$albuname" == "unknown_album" ]] && [[ "$bandname" == "unknown_artist" ]]; then
  echo -e "${rot}dieses verzeichnis konnte nicht eindeutig identifiziert werden, wird gelassen, wie es ist${off}\n hier sollten optionen zur auswahl hin"
  prob+=("$1")

elif [[ -d "$top_music_dir$bandname - $albuname" ]] && [[ $(dirname "${1}")/ == "$top_music_dir" ]]; then
  echo -e "this is already under top level and correctly named... ${blu}skipping${off}"

else
  while [[ -d "$top_music_dir$bandname - $albuname" ]] && [[ ! $(dirname "$1")/ == "$top_music_dir" ]]; do
    albuname="$albuname"_1
  done
  echo "$1 to $top_music_dir$bandname - $albuname"
  echo -e "$1 wird umbenannt und verschoben nach ${grn}\"$top_music_dir$bandname - $albuname\"${off}\n\n"
  read -n 1 -p "do you like that [y/n]?" yn
  case "$yn" in
    [Yy] ) set -x; cp -R   "$1"  "$top_music_dir$bandname - $albuname" && rm -r "$1"; set +x;;
  [Nn] ) continue ;;
esac
  fi
else
  echo "$1 ist weder ein vorhandenes Verzeichnis noch eine Datei? exiting..."    # wenn $1 weder ein file noch ein directory ist; dieser check sollte an den Anfang, nicht ans Ende
  exit
fi
}

## gucken, ob's im Ordner weitere Unterordner gibt
checksb () {
  find $1 -mindepth 1 -maxdepth 1 -type d
}

# in Unterverzeichnisse absteigen und gucken, ob's Audiodateien gibt
checksub () {
  if [[ -n "$(checksb $1)" ]]; then		## wenn der Rückgabewert nicht leer ist, sind Unterverzeichnisse vorhanden
    echo "subdir found in $1, descending"
    for i in $(checksb $1); do			## jedes Unterverzeichnis angucken und ggf. weiter absteigen
      echo -e "\n"
      checksub "$i"
    done
  else
    echo -n -e "${grn}$i${off} is a leaf node"			## wenn keine Unterverzeichnisse da sind, ist es ein Leaf
    dir_analysis "$i"
  fi
}



##### MAIN
checksub "$top_music_dir"
echo -e "audio dirs that were problematic:"
echo -e "${rot}${prob[*]}${off}" 
